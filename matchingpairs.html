<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match Up - Interactive Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {"theme":{"extend":{"colors":{"primary":"#007AFF","secondary":"#34C759","accent":"#FF9500","destructive":"#FF3B30","macos_bg_light":"#F6F6F6","macos_bg_dark":"#2D2D2D","macos_secondary_bg_light":"#FFFFFF","macos_secondary_bg_dark":"#3C3C3C","macos_tertiary_bg_light":"#EFEFEF","macos_tertiary_bg_dark":"#232323","macos_label_light":"#000000","macos_label_dark":"#FFFFFF","macos_secondary_label_light":"rgba(60, 60, 67, 0.6)","macos_secondary_label_dark":"rgba(235, 235, 245, 0.6)","macos_separator_light":"rgba(60, 60, 67, 0.15)","macos_separator_dark":"rgba(84, 84, 88, 0.4)","macos_placeholder_light":"rgba(60, 60, 67, 0.3)","macos_placeholder_dark":"rgba(235, 235, 245, 0.3)","macos_control_bg_light":"#FFFFFF","macos_control_bg_dark":"#5A5A5A","macos_control_border_light":"#CCCCCC","macos_control_border_dark":"#4A4A4A"}}},"darkMode":"class"}
    </script>
    <style> 
        /* Ensure cells have consistent height regardless of content */
        .matchup-dropzone .matchup-definition {
            width: 100%;
            height: 100%;
            border: none;
            box-shadow: none;
        }
        .dragging { opacity: 0.4; }
        .drag-over { background-color: rgba(0, 122, 255, 0.1); border-color: #007AFF !important; }
        
        /* Fixed height for all matching rows */
        .match-row-height { height: 3.5rem; } /* h-14 equivalent */
    </style>
</head>
<body class="p-4 sm:p-6 bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100">
    <h1 class="text-2xl font-semibold text-center mb-6">Match Up</h1>
    
    <div id="standalone-activity" class="max-w-4xl mx-auto bg-white dark:bg-gray-700 p-6 rounded-xl shadow-lg">
        </div>

    <script type="module">
    const matchupTemplate = (() => {
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function generateHTML(pairs) {
            const definitions = pairs.map(p => ({ id: p.id, text: p.definition }));
            const shuffledDefinitions = shuffleArray([...definitions]);

            // Create column headers
            const headerHTML = `
                <div class="grid grid-cols-3 gap-4 mb-2 text-xs font-bold uppercase text-gray-500 tracking-wider">
                    <div>Terms</div>
                    <div>Matches</div>
                    <div class="pl-4 border-l border-gray-200 dark:border-gray-600">Definitions</div>
                </div>`;

            let termsHTML = '<div id="matchup-terms-list" class="space-y-2">';
            pairs.forEach(pair => {
                termsHTML += `
                    <div class="matchup-term-only p-3 bg-macos_tertiary_bg_light dark:bg-macos_secondary_bg_dark rounded border border-macos_separator_light dark:border-macos_separator_dark match-row-height flex items-center justify-between" data-pair-id="${pair.id}">
                        <span class="truncate font-medium">${pair.term}</span>
                        <span class="matchup-term-status text-lg w-5 text-center shrink-0 ml-2"></span>
                    </div>`;
            });
            termsHTML += '</div>';

            let dropzonesHTML = '<div id="matchup-dropzone-list" class="space-y-2">';
            pairs.forEach(pair => {
                dropzonesHTML += `<div class="matchup-dropzone border-2 border-dashed border-macos_control_border_light dark:border-macos_control_border_dark rounded match-row-height flex items-center justify-center p-0 overflow-hidden transition-colors" data-term-id="${pair.id}"></div>`;
            });
            dropzonesHTML += '</div>';

            let definitionsHTML = '<div id="matchup-definitions-list" class="space-y-2 border-l border-gray-200 dark:border-gray-600 pl-4">';
            shuffledDefinitions.forEach(definition => {
                definitionsHTML += `
                    <div class="matchup-definition bg-white dark:bg-gray-600 border border-macos_control_border_light dark:border-macos_control_border_dark rounded shadow-sm cursor-grab active:cursor-grabbing select-none p-2 match-row-height flex items-center justify-center text-center transition-all" draggable="true" id="definition-${definition.id}" data-pair-id="${definition.id}">
                        ${definition.text}
                    </div>`;
            });
            definitionsHTML += '</div>';

            const finalHTML = `
                <div class="matchup-container flex flex-col">
                    ${headerHTML}
                    <div class="grid grid-cols-3 gap-4 mb-6">
                        ${termsHTML}${dropzonesHTML}${definitionsHTML}
                    </div>
                    <div class="flex justify-center gap-4 pt-6 border-t border-gray-200 dark:border-gray-600">
                         <button id="matchup-check-btn" class="px-6 py-2 bg-secondary text-white rounded-lg font-medium hover:brightness-110 transition-all">Check Answers</button>
                         <button id="matchup-show-btn" class="px-6 py-2 bg-primary text-white rounded-lg font-medium hover:brightness-110 transition-all">Show Answers</button>
                         <button id="matchup-reset-btn" class="px-6 py-2 bg-accent text-white rounded-lg font-medium hover:brightness-110 transition-all">Reset Game</button>
                    </div>
                </div>`;

            return { html: finalHTML, state: { pairs: pairs } };
        }

        function addInteractivity(activityElement, state) {
            const pool = activityElement.querySelector('#matchup-definitions-list');
            const dropzones = activityElement.querySelectorAll('.matchup-dropzone');
            let draggedItem = null;

            // Use event delegation for dragstart to handle items in pool or dropzones
            activityElement.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('matchup-definition')) {
                    draggedItem = e.target;
                    e.dataTransfer.setData('text/plain', e.target.id);
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => e.target.classList.add('dragging'), 0);
                    
                    // Clear row status if moving an item out of a zone
                    if (e.target.parentElement.classList.contains('matchup-dropzone')) {
                        const zone = e.target.parentElement;
                        const status = activityElement.querySelector(`.matchup-term-only[data-pair-id="${zone.dataset.termId}"] .matchup-term-status`);
                        if (status) status.textContent = '';
                        zone.classList.remove('bg-green-50', 'bg-red-50', 'border-green-500', 'border-red-500');
                    }
                }
            });

            activityElement.addEventListener('dragend', (e) => {
                if (e.target.classList.contains('matchup-definition')) {
                    e.target.classList.remove('dragging');
                    draggedItem = null;
                }
            });

            // Allow dropping back into the definitions pool
            pool.addEventListener('dragover', (e) => e.preventDefault());
            pool.addEventListener('drop', (e) => {
                e.preventDefault();
                if (draggedItem) {
                    pool.appendChild(draggedItem);
                    draggedItem.classList.remove('border-none');
                }
            });

            dropzones.forEach(zone => {
                zone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    zone.classList.add('drag-over');
                });
                zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
                zone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    zone.classList.remove('drag-over');
                    
                    if (!draggedItem) return;

                    // Swap logic: if box is full, move existing item back to the pool
                    if (zone.children.length > 0 && zone.children[0] !== draggedItem) {
                        const existing = zone.children[0];
                        pool.appendChild(existing);
                    }
                    
                    zone.appendChild(draggedItem);
                });
            });

            // Button controls
            activityElement.querySelector('#matchup-check-btn').addEventListener('click', () => checkAnswers(activityElement));
            activityElement.querySelector('#matchup-show-btn').addEventListener('click', () => showAnswers(activityElement, state));
            activityElement.querySelector('#matchup-reset-btn').addEventListener('click', () => resetGame(activityElement, state));
        }

        function checkAnswers(activityElement) {
            const dropzones = activityElement.querySelectorAll('.matchup-dropzone');
            dropzones.forEach(zone => {
                const termId = zone.dataset.termId;
                const dropped = zone.querySelector('.matchup-definition');
                const status = activityElement.querySelector(`.matchup-term-only[data-pair-id="${termId}"] .matchup-term-status`);
                
                zone.classList.remove('bg-green-50', 'bg-red-50', 'border-green-500', 'border-red-500');
                if (dropped) {
                    if (dropped.dataset.pairId === termId) {
                        zone.classList.add('bg-green-50', 'border-green-500');
                        status.textContent = '✅';
                    } else {
                        zone.classList.add('bg-red-50', 'border-red-500');
                        status.textContent = '❌';
                    }
                }
            });
        }

        function showAnswers(activityElement, state) {
            state.pairs.forEach(pair => {
                const def = activityElement.querySelector(`#definition-${pair.id}`);
                const zone = activityElement.querySelector(`.matchup-dropzone[data-term-id="${pair.id}"]`);
                if (def && zone) {
                    zone.appendChild(def);
                }
            });
            checkAnswers(activityElement);
        }

        function resetGame(activityElement, state) {
            const pool = activityElement.querySelector('#matchup-definitions-list');
            const allDefinitions = Array.from(activityElement.querySelectorAll('.matchup-definition'));
            
            activityElement.querySelectorAll('.matchup-dropzone').forEach(z => {
                z.innerHTML = '';
                z.classList.remove('bg-green-50', 'bg-red-50', 'border-green-500', 'border-red-500');
            });
            activityElement.querySelectorAll('.matchup-term-status').forEach(s => s.textContent = '');

            shuffleArray(allDefinitions).forEach(def => {
                def.setAttribute('draggable', 'true');
                pool.appendChild(def);
            });
        }

        return { generateHTML, addInteractivity };
    })();

    document.addEventListener('DOMContentLoaded', () => {
        const host = document.getElementById('standalone-activity');
        const state = {"pairs":[
            {"id":"pair-0","term":"1. A piece of","definition":"advice"},
            {"id":"pair-1","term":"2. A work of","definition":"art"},
            {"id":"pair-2","term":"3. A loaf of","definition":"bread"},
            {"id":"pair-3","term":"4. An ear of","definition":"corn"},
            {"id":"pair-4","term":"5. A jar of","definition":"honey"},
            {"id":"pair-5","term":"6. A pinch of","definition":"salt"},
            {"id":"pair-6","term":"7. A shot of","definition":"whiskey"},
            {"id":"pair-7","term":"8. A drop of","definition":"blood"}
        ]};
        
        const { html } = matchupTemplate.generateHTML(state.pairs);
        host.innerHTML = html;
        matchupTemplate.addInteractivity(host, state);
    });
    </script>
</body>
</html>
